/* -*-C++-*- */
/* This file contains the IR classes for all expressions.
   The base classes are in base.def */

abstract Operation_Unary : Operation {
    Expression expr;
    precedence = DBPrint::Prec_Prefix;
#emit
    Operation_Unary(Util::SourceInfo si, const Type *t, const Expression *e)
    : Operation(si, t), expr(e) {}
    Operation_Unary(const Type *t, const Expression *e) : Operation(t), expr(e) {}
    Operation_Unary(const Expression *e) : expr(e) {}
#end
}

class Neg : Operation_Unary {
    stringOp = "-";
#emit
    Neg(const Expression *e) : Operation_Unary(e) {}
#end
}

class Cmpl : Operation_Unary {
    stringOp = "~";
#emit
    Cmpl(const Expression *e) : Operation_Unary(e) {}
#end
}

class LNot : Operation_Unary {
    stringOp = "!";
#emit
    LNot(const Expression *e) : Operation_Unary(e) {}
#end
}

abstract Operation_Binary : Operation {
    Expression left;
    Expression right;
#emit
    Operation_Binary(const Expression *l, const Expression *r) : left(l), right(r) {}
#end
}

abstract Operation_Ternary : Operation {
    Expression e0;
    Expression e1;
    Expression e2;
#emit
    Operation_Ternary(const Expression *e0, const Expression *e1, const Expression *e2)
    : e0(e0), e1(e1), e2(e2) {}
#end
}

abstract Operation_Relation : Operation_Binary {
#emit
    Operation_Relation(const Expression *l, const Expression *r) : Operation_Binary(l, r) {}
#end
}

class Mul : Operation_Binary {
    stringOp = "*";
    precedence = DBPrint::Prec_Mul;
#emit
    Mul(const Expression *l, const Expression *r) : Operation_Binary(l, r) {}
#end
}

class Div : Operation_Binary {
    stringOp = "/";
    precedence = DBPrint::Prec_Div;
#emit
    Div(const Expression *l, const Expression *r) : Operation_Binary(l, r) {}
#end
}
class Mod : Operation_Binary {
    stringOp = "%";
    precedence = DBPrint::Prec_Mod;
#emit
    Mod(const Expression *l, const Expression *r) : Operation_Binary(l, r) {}
#end
}
class Add : Operation_Binary {
    stringOp = "+";
    precedence = DBPrint::Prec_Add;
#emit
    Add(const Expression *l, const Expression *r) : Operation_Binary(l, r) {}
#end
}
class Sub : Operation_Binary {
    stringOp = "-";
    precedence = DBPrint::Prec_Sub;
#emit
    Sub(const Expression *l, const Expression *r) : Operation_Binary(l, r) {}
#end
}
class Shl : Operation_Binary {
    stringOp = "<<";
    precedence = DBPrint::Prec_Shl;
#emit
    Shl(const Expression *l, const Expression *r) : Operation_Binary(l, r) {}
#end
}
class Shr : Operation_Binary {
    stringOp = ">>";
    precedence = DBPrint::Prec_Shr;
#emit
    Shr(const Expression *l, const Expression *r) : Operation_Binary(l, r) {}
#end
}
class Equ : Operation_Relation {
    stringOp = "==";
    precedence = DBPrint::Prec_Equ;
#emit
    Equ(const Expression *l, const Expression *r) : Operation_Relation(l, r) {}
#end
}
class Neq : Operation_Relation {
    stringOp = "!=";
    precedence = DBPrint::Prec_Neq;
#emit
    Neq(const Expression *l, const Expression *r) : Operation_Relation(l, r) {}
#end
}
class Lss : Operation_Relation {
    stringOp = "<";
    precedence = DBPrint::Prec_Lss;
#emit
    Lss(const Expression *l, const Expression *r) : Operation_Relation(l, r) {}
#end
}
class Leq : Operation_Relation {
    stringOp = "<=";
    precedence = DBPrint::Prec_Leq;
#emit
    Leq(const Expression *l, const Expression *r) : Operation_Relation(l, r) {}
#end
}
class Grt : Operation_Relation {
    stringOp = ">";
    precedence = DBPrint::Prec_Grt;
#emit
    Grt(const Expression *l, const Expression *r) : Operation_Relation(l, r) {}
#end
}
class Geq : Operation_Relation {
    stringOp = ">=";
    precedence = DBPrint::Prec_Geq;
#emit
    Geq(const Expression *l, const Expression *r) : Operation_Relation(l, r) {}
#end
}
class BAnd : Operation_Binary {
    stringOp = "&";
    precedence = DBPrint::Prec_BAnd;
#emit
    BAnd(const Expression *l, const Expression *r) : Operation_Binary(l, r) {}
#end
}
class BOr : Operation_Binary {
    stringOp = "|";
    precedence = DBPrint::Prec_BOr;
#emit
    BOr(const Expression *l, const Expression *r) : Operation_Binary(l, r) {}
#end
}
class BXor : Operation_Binary {
    stringOp = "^";
    precedence = DBPrint::Prec_BXor;
#emit
    BXor(const Expression *l, const Expression *r) : Operation_Binary(l, r) {}
#end
}
class LAnd : Operation_Binary {
    stringOp = "&&";
    precedence = DBPrint::Prec_LAnd;
#emit
    LAnd(const Expression *l, const Expression *r) : Operation_Binary(l, r) {}
#end
}
class LOr : Operation_Binary {
    stringOp = "||";
    precedence = DBPrint::Prec_LOr;
#emit
    LOr(const Expression *l, const Expression *r) : Operation_Binary(l, r) {}
#end
}

// This is an integer literal on arbitrary-precision.
class Constant : Expression, CompileTimeValue {
    mpz_class value;
    unsigned  base;  // base used when reading/writing
#noconstructor
#emit
    // if noWarning is true, no warning is emitted
    void handleOverflow(bool noWarning);
    explicit Constant(intmax_t v, unsigned base = 10) :
            Expression(new Type_InfInt()), value(v), base(base) {}
    explicit Constant(mpz_class v, unsigned base = 10) :
            Expression(new Type_InfInt()), value(v), base(base) {}
    Constant(Util::SourceInfo si, mpz_class v, unsigned base = 10) :
            Expression(si, new Type_InfInt()), value(v), base(base) {}
    Constant(const Type *t, mpz_class v, unsigned base = 10, bool noWarning = false) :
            Expression(t), value(v), base(base) { CHECK_NULL(t); handleOverflow(noWarning); }
    Constant(Util::SourceInfo si, const Type *t, mpz_class v,
             unsigned base = 10, bool noWarning = false) :
            Expression(si, t), value(v), base(base) { CHECK_NULL(t); handleOverflow(noWarning); }
    static Constant GetMask(unsigned width);
    bool fitsInt() const { return value.fits_sint_p(); }
    bool fitsLong() const { return value.fits_slong_p(); }
    long asLong() const {
        if (!fitsLong())
            ::error("%1%: Value too large", this);
        return value.get_si(); }
    int asInt() const {
        if (!fitsInt())
            ::error("%1%: Value too large", this);
        return value.get_si(); }
    // The following operators are only used in special circumstances.
    // They do not look at the type when operating.  There are separate
    // implementations of these computations when doing proper constant folding.
    Constant operator<<(const unsigned &shift) const;
    Constant operator>>(const unsigned &shift) const;
    Constant operator&(const Constant &c) const;
    Constant operator-(const Constant &c) const;
#end
    toString { return Util::toString(&value); }
}

class BoolLiteral : Expression, CompileTimeValue {
    bool value;
    toString{ return value ? "true" : "false"; }
}

class StringLiteral : Expression {
    cstring value;
    validate{ if (value.isNull()) BUG("null StringLiteral"); }
    toString{ return cstring("\"") + value + "\""; }
}

class PathExpression : Expression {
    Path path;
#noconstructor
#emit
    explicit PathExpression(IR::ID id) :
            Expression(id.srcInfo), path(new IR::Path(id)) {}
    explicit PathExpression(const Path* path)
        : Expression(path->srcInfo), path(path)
    { CHECK_NULL(path); }
#end
    toString{ return path->toString(); }
}

// enum X { a }
// X.a
// The 'X' portion is a TypeNameExpression
class TypeNameExpression : Expression {
    Type_Name typeName;
#emit
    TypeNameExpression(ID id) : typeName(new IR::Type_Name(new IR::Path(id))) {}
#end
    dbprint{ Node::dbprint(out); out << typeName; }
    toString { return typeName->toString(); }
}

class Slice : Operation_Ternary {
    precedence = DBPrint::Prec_Postfix;
    stringOp = "[:]";
    toString{ return e0->toString() + "[" + e1->toString() + ":" + e2->toString() + "]"; }
    // After type checking e1 and e2 will be constants
#emit
    int getH() const { return e1->to<IR::Constant>()->asInt(); }
    int getL() const { return e2->to<IR::Constant>()->asInt(); }
    Slice(const Expression *a, int hi, int lo)
    : Operation_Ternary(a, new Constant(hi), new Constant(lo)) {}
    Slice(const Util::SourceInfo &si, const Expression *a, int hi, int lo)
    : Operation_Ternary(si, a, new Constant(hi), new Constant(lo)) {}
#end
}

class Member : Operation_Unary {
    ID member;
#emit
    Member(Util::SourceInfo si, const Type *t, const Expression *b, cstring n)
    : Operation_Unary(si, t, b), member(n) {}
    Member(const Expression *b, ID n) : Operation_Unary(b), member(n) {}
    Member(const Type *t, const Expression *b, cstring n) : Operation_Unary(t, b), member(n) {}
    virtual int offset_bits() const;
    int lsb() const;
    int msb() const;
#end
    stringOp = ".";
    toString{ return expr->toString() + "." + member; }
}

class Concat : Operation_Binary {
    stringOp = "++";
    precedence = DBPrint::Prec_Add;
}

class ArrayIndex : Operation_Binary {
    stringOp = "[]";
    precedence = DBPrint::Prec_Postfix;
}

class Range : Operation_Binary {
    stringOp = "..";
    precedence = DBPrint::Prec_Low;
}

class Mask : Operation_Binary {
    stringOp = "&&&";
    precedence = DBPrint::Prec_Low;
}

class Mux : Operation_Ternary {
    stringOp = "?:";
    precedence = DBPrint::Prec_Low;
}

class DefaultExpression : Expression {}

class This : Expression {}  // experimental

class Cast : Operation_Unary {
    Type destType;
#emit
    // We set both type and destType.
    Cast(Util::SourceInfo srcInfo, const IR::Type* type, const IR::Expression *expression) :
            Operation_Unary(srcInfo, type, expression), destType(type) {}
#end
    precedence = DBPrint::Prec_Prefix;
    stringOp = "(cast)";
    toString{ return "cast"; }
    validate{ if (destType->is<Type_Unknown>()) BUG("%1%: Cannot cast to unknown type", this); }
}

class SelectExpression : Expression {
    ListExpression select;
    Vector<SelectCase> selectCases;
#nodbprint
    validate{ selectCases->check_null(); }
}

class MethodCallExpression : Expression {
    Expression method;
    Vector<Type> typeArguments;
    Vector<Expression> arguments;
    toString{ return method->toString(); }
    validate{ typeArguments->check_null(); arguments->check_null(); }
}

class ConstructorCallExpression : Expression {
    Type               constructedType;
    Vector<Expression> arguments;
#noconstructor
#emit
    ConstructorCallExpression(Util::SourceInfo srcInfo, const Type* type,
                              const Vector<Expression> *arguments) :
            Expression(srcInfo), constructedType(type), arguments(arguments) {}
#end
    toString{ return constructedType->toString(); }
    validate{ arguments->check_null(); }
}

// Represents a list of expressions separated by commas
class ListExpression : Expression {
    Vector<Expression> components;
    validate {
        if (components->empty()) BUG("List expression with no components");
        components->check_null();
    }
}
