/* -*-C++-*- */

/*
  P4 compiler IR definition file.
  To understand this you really have to understand the shape of the generated IR code.

  The IR builder "knows" the following methods for a class T:

  cstring toString() const override;
  void dbprint(std::ostream &out) const override;
  bool operator==(const T &a) const;
  void validate() const;
  const char *node_type_name() const;
  void visit_children(Visitor &v);
  void dump_fields(std::ostream& out) const;

  C comments are ignored.
  C++ line comments can appear in some places and are emitted in the output.

  #emit/#end   -> copy text literally to output
  #noXXX       -> do not emit the specified implementation for the XXX method
                  e.g., #noconstructor, #nodbprint, #novisit_children
  #apply       -> generate apply overload for visitors
  method{ ... } -> specifies an implementation for a default method
                   method can be 'operator=='

  Some assignments are turned into methods returning constant values:
  stringOp     -> cstring getStringOp() const
  precedence   -> int getPrecedence() const
 */

class SelectCase {
    Expression     keyset;
    PathExpression state;
#nodbprint
}

class ParserState : IGeneralNamespace, Declaration {
    Annotations              annotations;
    Vector<StatOrDecl>       components;
    // selectExpression can be a SelectExpression, or a PathExpression representing a state
    NullOK Expression        selectExpression;
#emit
    Util::Enumerator<const IDeclaration*>* getDeclarations() const
    { return components->only<IDeclaration>(); }

    static const ID accept;
    static const ID reject;
    static const ID start;
    bool isBuiltin() const { return name == ParserState::accept || name == ParserState::reject; }
#end
#nodbprint
    validate{ components->check_null(); }
}

// A parser that contains all states (unlike the P4 v1.0 parser, which is really just a state)
class P4Parser : Type_Declaration, IGeneralNamespace, IApply, IContainer {
    Type_Parser          type;
    ParameterList        constructorParams;
    Vector<Declaration>  stateful;
    Vector<ParserState>  states;
#emit
    const TypeParameters* getTypeParameters() const { return type->getTypeParameters(); }
    Util::Enumerator<const IDeclaration*>* getDeclarations() const
    { return stateful->getEnumerator()->
                       as<const IDeclaration*>()->
                       concat(states->only<IDeclaration>()); }
    const Type_Method* getApplyMethodType() const { return type->getApplyMethodType(); }
    const Type_Method* getConstructorMethodType() const override;
#end
#apply
#nodbprint
    validate {
        if (!(name == type->name))
            BUG("Name mismatch for %1%: %2% != %3%", this, name, type->name);
        stateful->check_null();
        states->check_null();
    }
    toString { return cstring("parser ") + name; }
}

class P4Control : Type_Declaration, ISimpleNamespace, IApply, IContainer {
    Type_Control         type;
    ParameterList        constructorParams;
    inline NameMap<Declaration, ordered_map>  stateful;
    BlockStatement       body;
#emit
    Util::Enumerator<const Declaration*>* statefulEnumerator() const
    { return stateful.valueEnumerator(); }
    const TypeParameters* getTypeParameters() const { return type->getTypeParameters(); }
    Util::Enumerator<const IDeclaration*>* getDeclarations() const;
    const Type_Method* getApplyMethodType() const { return type->getApplyMethodType(); }
    const Type_Method* getConstructorMethodType() const override;
    const IDeclaration* getDeclByName(cstring name) const
    { return stateful.getUnique(name); }
#end
#apply
#nodbprint
    validate {
        if (!(name == type->name))
            BUG("Name mismatch for %1%: %2% != %3%", this, name, type->name);
        stateful.check_null();
    }
    toString { return cstring("control ") + name; }
}

class P4Action : Declaration, IGeneralNamespace {
    Annotations        annotations;
    ParameterList      parameters;
    Vector<StatOrDecl> body;
#emit
    Util::Enumerator<const IDeclaration*>* getDeclarations() const
    { return body->only<IDeclaration>(); }
#end
#nodbprint
    validate{ body->check_null(); }
}

class Declaration_Errors : Declaration, ISimpleNamespace {
    inline NameMap<Declaration_ID, ordered_map> members;
#emit
    static const ID EID;
    Util::Enumerator<const IDeclaration*>* getDeclarations() const
    { return getEnumerator()->as<const IDeclaration*>(); }
    Util::Enumerator<const Declaration_ID*>* getEnumerator() const
    { return members.valueEnumerator(); }
    const IDeclaration* getDeclByName(cstring name) const
    { return members.getUnique(name); }
#end
#nodbprint
    validate{ members.check_null(); }
}

class Declaration_MatchKind : Declaration, ISimpleNamespace {
    inline NameMap<Declaration_ID, ordered_map> members;
#emit
    static const ID MKID;
    Util::Enumerator<const IDeclaration*>* getDeclarations() const
    { return getEnumerator()->as<const IDeclaration*>(); }
    Util::Enumerator<const Declaration_ID*>* getEnumerator() const
    { return members.valueEnumerator(); }
    const IDeclaration* getDeclByName(cstring name) const
    { return members.getUnique(name); }
#end
#nodbprint
    validate{ members.check_null(); }
}

// Table property value abstract base class
abstract PropertyValue {
#nodbprint
}

// A property whose value is an expression
class ExpressionValue : PropertyValue {
    Expression expression;
#nodbprint
}

// An element in a table actions list
class ActionListElement {
    Annotations               annotations;
    PathExpression            name;
    NullOK Vector<Expression> arguments;
#nodbprint
#emit
    ID getName() const { return name->path->name; }
#end
}

// A list of actions (in a table)
class ActionList : PropertyValue {
    Vector<ActionListElement> actionList;
#emit
    void checkDuplicates() const;
#end
#nodbprint
    validate{ checkDuplicates(); actionList->check_null(); }
}

class KeyElement {
    Expression      expression;
    PathExpression  matchType;
    dbprint{ Node::dbprint(out); out << "_:" << matchType; }
}

// Value of a table key property
class Key : PropertyValue {
    Vector<KeyElement> keyElements;
#nodbprint
    validate { keyElements->check_null(); }
}

class TableProperty : Declaration {
    Annotations   annotations;
    PropertyValue value;
    bool          isConstant;
#nodbprint
}

class TableProperties : ISimpleNamespace {
    inline NameMap<TableProperty, ordered_map> properties;
    toString{ return "TableProperties(" + Util::toString(properties.size()) + ")"; }
#emit
    TableProperties() {}
    Util::Enumerator<const IDeclaration*>* getDeclarations() const
    { return getEnumerator()->as<const IDeclaration*>(); }
    const TableProperty* getProperty(cstring name) const
    { return properties.getUnique(name); }
    Util::Enumerator<const TableProperty*>* getEnumerator() const
    { return properties.valueEnumerator(); }
    const IDeclaration* getDeclByName(cstring name) const
    { return properties.getUnique(name); }

    static const cstring actionsPropertyName;
    static const cstring keyPropertyName;
    static const cstring defaultActionPropertyName;
#end
#nodbprint
    validate{ properties.check_null(); }
}

class P4Table : Declaration {
    Annotations     annotations;
    ParameterList   parameters;
    TableProperties properties;
#emit
    const ActionList* getActionList() const {
        auto ap = properties->getProperty(TableProperties::actionsPropertyName);
        if (ap == nullptr)
            return nullptr;
        if (!ap->value->is<IR::ActionList>()) {
            ::error("%1% must be an action list", ap);
            return nullptr;
        }
        return ap->value->to<IR::ActionList>();
    }
    const Key* getKey() const {
        auto kp = properties->getProperty(TableProperties::keyPropertyName);
        if (kp == nullptr)
            return nullptr;
        if (!kp->value->is<IR::Key>()) {
            ::error("%1% must be a key", kp);
            return nullptr;
        }
        return kp->value->to<IR::Key>();
    }
#end
#nodbprint
}

class Declaration_Variable : Declaration {
    Annotations        annotations;
    Type               type;
    NullOK Expression  initializer;
#nodbprint
}

class Declaration_Constant : Declaration {
    Annotations        annotations;
    Type               type;
    Expression         initializer;
#nodbprint
    toString { return Declaration::toString(); }
}

// Like a variable, but for a statically allocated instance
class Declaration_Instance : Declaration {
    Type               type;
    Vector<Expression> arguments;
    Annotations        annotations;
#nodbprint
    validate{ arguments->check_null(); }
}

// Toplevel program representation
class P4Program : IGeneralNamespace {
    Vector<Node> declarations;
    validate{ checkDeclarations(); }
#emit
    Util::Enumerator<const IDeclaration*>* getDeclarations() const
    { return declarations->getEnumerator()->as<const IDeclaration*>(); }
    void checkDeclarations() const;
    static const cstring main;
#end
#apply
#nodbprint
}

abstract Statement : StatOrDecl {
#nodbprint
}

class ExitStatement : Statement {
    toString{ return "exit"; }
#nodbprint
}

class ReturnStatement : Statement {
    toString{ return "return"; }
#nodbprint
}

class EmptyStatement : Statement {
#nodbprint
}

class AssignmentStatement : Statement {
    Expression left;
    Expression right;
    dbprint{ out << left << " = " << right; }
}

class IfStatement : Statement {
    Expression       condition;
    Statement        ifTrue;
    NullOK Statement ifFalse;
#nodbprint
}

class BlockStatement : Statement, IGeneralNamespace {
    Vector<StatOrDecl> components;
#emit
    Util::Enumerator<const IDeclaration*>* getDeclarations() const
    { return components->only<IDeclaration>(); }
#end
#nodbprint
}

class MethodCallStatement : Statement {
    MethodCallExpression methodCall;
}

class SwitchCase {
    ID        label;
    NullOK Statement statement;  // If missing then it's a fall-through
#nodbprint
}

// The type system will enforce the fact that
// expression is IR::Member(IR::MethodCallExpression(table_apply), Type_Table::action_run)
class SwitchStatement : Statement {
    Expression expression;
    Vector<SwitchCase> cases;
#nodbprint
#emit
    // 'default': a legal label for a switch statement
    static const cstring default_label;
#end
}

/////////////////////////////////////////////////////////////

// Block is the base class for IR nodes produced by the evaluator.
// A block represents a compile-time allocated resource.
abstract Block : CompileTimeValue {
    Node node;  // Node that evaluates to this block.
    // It's either a Declaration_Instance or a ConstructorCallExpression.
#emit
    // One value for each Node inside that evaluates to a compile-time constant.
    // This includes all constructor parameters.
    std::map<const Node*, const CompileTimeValue*> constantValue;

    virtual void dbprint(std::ostream& out) const;
    virtual void dbprint_recursive(std::ostream& out) const;
    void setValue(const Node* node, const CompileTimeValue* value) {
        CHECK_NULL(node); CHECK_NULL(value);
        auto v = get(constantValue, node);
        BUG_CHECK(v == nullptr, "%1% already set", node);
        constantValue.emplace(node, value);
    }
    const CompileTimeValue* getValue(const Node* node) const {
        CHECK_NULL(node);
        return ::get(constantValue, node);
    }
#end
    visit_children { (void)v; }
}

class TableBlock : Block {
    P4Table container;
#nodbprint
}

// An object that has been instantiated
// The substitution holds the constructor arguments.
abstract InstantiatedBlock : Block {
    Type instanceType;  // May be a SpecializedType
#emit
    virtual const IR::ParameterList* getConstructorParameters() const = 0;
    void instantiate(std::vector<const IR::CompileTimeValue*> *args);
    const CompileTimeValue* getParameterValue(cstring paramName) const;
    virtual void dbprint(std::ostream& out) const;
#end
}

class ParserBlock : InstantiatedBlock {
    P4Parser container;
#emit
    const IR::ParameterList* getConstructorParameters() const override
    { return container->constructorParams; }
#end
#nodbprint
}

class ControlBlock : InstantiatedBlock {
    P4Control container;
#emit
    const IR::ParameterList* getConstructorParameters() const override
    { return container->constructorParams; }
#end
#nodbprint
}

class PackageBlock : InstantiatedBlock {
    Type_Package type;
#emit
    const IR::ParameterList* getConstructorParameters() const override
    { return type->constructorParams; }
#end
#nodbprint
}

class ExternBlock : InstantiatedBlock {
    Type_Extern type;
    Method      constructor;  // used to instantiate this block
#emit
    const IR::ParameterList* getConstructorParameters() const override
    { return constructor->type->parameters; }
#end
#nodbprint
}

// Represents the program as a whole
class ToplevelBlock : Block {
#nodbprint
}
