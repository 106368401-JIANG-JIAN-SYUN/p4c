<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>P4C: P4 Compiler Intermediate representation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="p4c.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="p4-logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">P4C
   </div>
   <div id="projectbrief">The P4 Compiler</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('md___users_cascaval__barefoot__projects__p4_src_p4c_docs__i_r.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">P4 Compiler Intermediate representation </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>Introduction</h2>
<p>This document outlines the design of the P4_16 compiler. It lays out the various classes and data structures used for the compiler and describes the general flow of the compilation process. The compiler is designed to operate in the `traditional’ manner, converting the source P4 program to an internal representation, the performing a series of transformational passes on the <a class="el" href="namespace_i_r.html" title="a value that can be evaluated at compile-time ">IR</a>, culminating in an <a class="el" href="namespace_i_r.html" title="a value that can be evaluated at compile-time ">IR</a> representation that maps more or less directly to the target code. Along the way, the set of <a class="el" href="namespace_i_r.html" title="a value that can be evaluated at compile-time ">IR</a> classes present in the code may change, with certain constructs appearing only in the initial <a class="el" href="namespace_i_r.html" title="a value that can be evaluated at compile-time ">IR</a> from the parser, and other constructs being introduced through the compilation process.</p>
<p>Novel to this design is the ability to always return to an earlier version of the <a class="el" href="namespace_i_r.html" title="a value that can be evaluated at compile-time ">IR</a> (backtracking across passes) or use multiple threads to operate on the <a class="el" href="namespace_i_r.html" title="a value that can be evaluated at compile-time ">IR</a>, allowing different strategies to be tried in the search for a final result. Allowing this forking and backtracking is central to the <a class="el" href="namespace_i_r.html" title="a value that can be evaluated at compile-time ">IR</a> and transformation design. The <a class="el" href="namespace_i_r.html" title="a value that can be evaluated at compile-time ">IR</a> is designed to represent the program as a tree or DAG from a single root node, with each node referring only to its children. Transformations operate by creating new <a class="el" href="namespace_i_r.html" title="a value that can be evaluated at compile-time ">IR</a> nodes that are shallow copies of existing nodes, and then creating new parent nodes to refer to these new nodes, up to the root of the <a class="el" href="namespace_i_r.html" title="a value that can be evaluated at compile-time ">IR</a>. The internal representation is designed in C++ around a single inheritance object hierarchy with an ultimate base Node type used by all subclasses. The base Node class supports the functionality needed for visitor transformations – clone, equality tests, and subclass dispatch.</p>
<p>The <a class="el" href="namespace_i_r.html" title="a value that can be evaluated at compile-time ">IR</a> needs to be extensible, allowing for the addition of new classes to the hierarchy as support for new targets is added. The initial <a class="el" href="namespace_i_r.html" title="a value that can be evaluated at compile-time ">IR</a> produced by the parser contains constructs that are related only to the source P4 language, and there will be frontend transformation passes that convert things to a simpler and more canonical form.</p>
<p>The <a class="el" href="namespace_i_r.html" title="a value that can be evaluated at compile-time ">IR</a> may be a tree or DAG, but allowing back/up references in the <a class="el" href="namespace_i_r.html" title="a value that can be evaluated at compile-time ">IR</a> (cycles) defeats much of the benefit of the immutable <a class="el" href="namespace_i_r.html" title="a value that can be evaluated at compile-time ">IR</a>. If cycles (for example, leaf nodes for names directly referring to the named object) were allowed, pretty much any minor transform would end up cloning the entire <a class="el" href="namespace_i_r.html" title="a value that can be evaluated at compile-time ">IR</a> graph, as modifying a leaf involves cloning the object containing the leaf, and then any object referring to that object, recursively.</p>
<h2>Visitors and Transforms</h2>
<p>The compiler is organized as a series of <code><a class="el" href="class_visitor.html">Visitor</a></code> and <code><a class="el" href="class_transform.html">Transform</a></code> passes (<a href="https://en.wikipedia.org/wiki/Visitor_pattern">https://en.wikipedia.org/wiki/Visitor_pattern</a>). The <code><a class="el" href="class_visitor.html">Visitor</a></code> and <code><a class="el" href="class_transform.html">Transform</a></code> base classes make defining new passes easy &ndash; a new transform need only specify the <a class="el" href="namespace_i_r.html" title="a value that can be evaluated at compile-time ">IR</a> types it is interested in, and can ignore others. A (constant) <code><a class="el" href="class_visitor.html">Visitor</a></code> pass visits every node in the <a class="el" href="namespace_i_r.html" title="a value that can be evaluated at compile-time ">IR</a> tree and accumulates information about the tree but does not modify it, while a <a class="el" href="class_transform.html">Transform</a> pass visits every node, possibly modifying the node or replacing it with some other node</p>
<div class="fragment"><div class="line">{C++}</div><div class="line">    /* pseudo-code for basic Transform visitor */</div><div class="line">    visit(node, context=ROOT, visited={}) {</div><div class="line">    if (node in visited) {</div><div class="line">        if (visited[node] == INVALID)</div><div class="line">            throw loop_detected</div><div class="line">        if (VisitDagOnce)</div><div class="line">            return visited[node] }</div><div class="line">    visited[node] = INVALID</div><div class="line">    copy = shallow_clone(node)</div><div class="line">    if (VisitDagOnce)</div><div class="line">        forward_children(copy, visited)</div><div class="line">    copy = preorder(copy, context) // override in Transform subclass</div><div class="line">    visit_children(copy, {copy, context}, visited)</div><div class="line">    copy = postorder(copy, context) // override in Transform subclass</div><div class="line">    if (*copy == *node) {</div><div class="line">        visited[node] = node</div><div class="line">        return node</div><div class="line">    } else {</div><div class="line">        visited[node] = copy</div><div class="line">        return copy }</div><div class="line">    }</div><div class="line">    forward_children(node, visited) {</div><div class="line">    for (child in children(node))</div><div class="line">        if (child in visited)</div><div class="line">            child = visited[child]</div><div class="line">    }</div><div class="line">    visit_children(node, context, visited) {</div><div class="line">    for (child in children(node))</div><div class="line">        child = visit(child, context, visited)</div><div class="line">    }</div></div><!-- fragment --><p>A <code><a class="el" href="class_transform.html">Transform</a></code> pass is allowed to freely modify or completely replace a node in its preorder and postorder routines, and the <a class="el" href="class_transform.html">Transform</a> visitor will automatically rebuild the tree as needed. The transform subroutines cannot modify other nodes in the tree, however, though they may access and refer to them. These routines can be overloaded to differentiate between different <a class="el" href="namespace_i_r.html" title="a value that can be evaluated at compile-time ">IR</a> subclasses automatically. Any given visitor need only override the routines it is interested in for the <a class="el" href="namespace_i_r.html" title="a value that can be evaluated at compile-time ">IR</a> types it is interested in.</p>
<p>There are several <a class="el" href="class_visitor.html">Visitor</a> subclasses that describe different types of visitors:</p>
<table class="doxtable">
<tr>
<th><a class="el" href="class_visitor.html">Visitor</a> </th><th>Description  </th></tr>
<tr>
<td><code><a class="el" href="class_inspector.html">Inspector</a></code> </td><td>simplified visitor that does not modify any nodes, just collects information. </td></tr>
<tr>
<td><code><a class="el" href="class_modifier.html">Modifier</a></code> </td><td>simplified visitor that does not change the tree/dag structure, but may modify nodes in place. </td></tr>
<tr>
<td><code><a class="el" href="class_transform.html">Transform</a></code> </td><td>full transformation visitor described above </td></tr>
<tr>
<td><code><a class="el" href="class_pass_manager.html">PassManager</a></code> </td><td>combines several visitors, run in a sequence </td></tr>
</table>
<p>There are also some interfaces that <a class="el" href="class_visitor.html">Visitor</a> subclasses can implement to alter how nodes are visited:</p>
<table class="doxtable">
<tr>
<th>Interface </th><th>Description  </th></tr>
<tr>
<td><code><a class="el" href="class_control_flow_visitor.html">ControlFlowVisitor</a></code> </td><td>visit nodes in control-flow order, splitting (cloning) the visitor at conditions and merging the clone at join points </td></tr>
<tr>
<td><code><a class="el" href="class_backtrack.html">Backtrack</a></code> </td><td>visitor that is notified when backtracking occurs and can have its state saved as a backtrack point. </td></tr>
</table>
<h4><a class="el" href="class_control_flow_visitor.html">ControlFlowVisitor</a></h4>
<p>To support control flow analysis, there is a special <code><a class="el" href="class_control_flow_visitor.html">ControlFlowVisitor</a></code> interface that is understood by certain <a class="el" href="namespace_i_r.html" title="a value that can be evaluated at compile-time ">IR</a> subclasses that encapsulate control flow, and is used by them to control the order in which children are visited and the visitor state passed to the visitor preorder/postorder routines in order to implement control-flow analysis.</p>
<p>The basic idea is that control flow <a class="el" href="namespace_i_r.html" title="a value that can be evaluated at compile-time ">IR</a> nodes, when visiting their children, will create clones of the <code><a class="el" href="class_control_flow_visitor.html">ControlFlowVisitor</a></code> object to visit different children after a branch, and will then call <code>flow_merge</code> at the join point to merge the visitor state. Both the <code><a class="el" href="class_visitor.html">Visitor</a></code> base class and the <code><a class="el" href="class_control_flow_visitor.html">ControlFlowVisitor</a></code> interface define two virtual functions: <code>flow_clone</code> and <code>flow_merge</code> to mediate this. In the <code><a class="el" href="class_visitor.html">Visitor</a></code> base class (used by all visitors that do <em>not</em> inherit from the <code><a class="el" href="class_control_flow_visitor.html">ControlFlowVisitor</a></code> interface, these are implemented as no-ops &ndash; <code>flow_clone</code> just returns the same object, and <code>flow_merge</code> does nothing. In the <code><a class="el" href="class_control_flow_visitor.html">ControlFlowVisitor</a></code> interface <code>flow_clone</code> calls the <code>clone</code> function (which must be implemented by the leaf class) and <code>flow_merge</code> is an abstract virtual function that must be implemented by the leaf class.</p>
<p>As an example for how these are used in the <a class="el" href="namespace_i_r.html" title="a value that can be evaluated at compile-time ">IR</a> visitor routines, the <a class="el" href="class_i_r_1_1_if.html">IR::If</a> class has three children to visit &ndash; a predicate and two consequents, with the value of the predicate deciding which consequent to execute. The child visitor for <code><a class="el" href="class_i_r_1_1_if.html">IR::If</a></code> is</p>
<div class="fragment"><div class="line">{C++}</div><div class="line">    visitor.visit(predicate);</div><div class="line">    clone = visitor.flow_clone();</div><div class="line">    visitor.visit(ifTrue);</div><div class="line">    clone.visit(ifFalse);</div><div class="line">    visitor.flow_merge(clone);</div></div><!-- fragment --><p>So both consequents are visited with a visitor state that corresponds to the control flow immediately after evaluating the predicate, and then the control flow state after both consequents are merged back together.</p>
<p>In order to make use of this functionality, a <code><a class="el" href="class_visitor.html">Visitor</a></code> sub class need only inherit from the <code><a class="el" href="class_control_flow_visitor.html">ControlFlowVisitor</a></code> interface and implement the <code>clone</code> and <code>flow_merge</code> routines. Other <code><a class="el" href="class_visitor.html">Visitor</a></code> classes don't need to do anything, but may want to implement <code>clone</code> for other reasons.</p>
<p>This control flow analysis only works for branch-and-join control flow &ndash; it is not adequate for loops (which generally requires an iterate to fixed point process). As our <a class="el" href="namespace_i_r.html" title="a value that can be evaluated at compile-time ">IR</a> does not (currently) support loops this is fine. Since P4 does not allow loops in the match-action part of the pipeline, this works well there, but may be inadequate for parsers, which can support loops.</p>
<h2>Overall flow</h2>
<p>The compiler flow can be roughly split into frontend, middle-end, and backend. The frontend does largely non-target specific transforms designed to clean up the <a class="el" href="namespace_i_r.html" title="a value that can be evaluated at compile-time ">IR</a> and get it into a canonical form. The middle make target-dependent <a class="el" href="namespace_i_r.html" title="a value that can be evaluated at compile-time ">IR</a> transformations. The back end performs resource allocation decisions. As this backend step may fail due to constraint violations, it may need to backtrack through the middle-end to try a different configuration. We do not anticipate needing to backtrack through frontend passes. The split between Front/Middle/Back-end is largely arbitrary, and some passes may end up being moved between them if we later find it makes more sense to do so.</p>
<h3>Frontend</h3>
<p>The frontend parses the source code into <a class="el" href="namespace_i_r.html" title="a value that can be evaluated at compile-time ">IR</a> that corresponds directly to the source code. It then runs a series of passes like type-checking (modifying nodes to indicate their inferred types), constant folding, dead code elimination, etc. The initial <a class="el" href="namespace_i_r.html" title="a value that can be evaluated at compile-time ">IR</a> tree corresponds to the source code, and then various mostly target independent transformation are done. Complex scoping or structuring in the code is flattened here.</p>
<h3>Mid-end</h3>
<p>The mid-end is where transformations that depend somewhat on the target, but are not specific resource allocations, take place. At some point the mid-end transforms the <a class="el" href="namespace_i_r.html" title="a value that can be evaluated at compile-time ">IR</a> into a form that matches the target capabilities.</p>
<h3>Pass Managers</h3>
<p>To manage backtracking and control the order of passes and transforms, we use a <code><a class="el" href="class_pass_manager.html">PassManager</a></code> object which encapsulates a sequence of passes and runs them in order. Those passes that support the <code><a class="el" href="class_backtrack.html">Backtrack</a></code> interface are backtrack points.</p>
<p>The generic <code><a class="el" href="class_pass_manager.html">PassManager</a></code> can manage a dynamically chosen series of passes. It tracks passes that implement <code><a class="el" href="class_backtrack.html">Backtrack</a></code> and if a later pass fails, will backtrack to the <a class="el" href="class_backtrack.html">Backtrack</a> pass.</p>
<div class="fragment"><div class="line">interface Backtrack {</div><div class="line">   bool backtrack(trigger);</div><div class="line">}</div></div><!-- fragment --><p>The <code>backtrack</code> method is called when backtracking is triggered, with a trigger reason. Returns <code>true</code> if the pass can try a useful alternative, <code>false</code> if manager should search for some other backtracking point.</p>
<h3>Exception Use</h3>
<p>Exceptions are usable for errors that are reportable to the user, constraint problems that should result in backtracking and internal compiler problems. There are a number of exception classes designed for these purposes.</p>
<ul>
<li><code><a class="el" href="struct_backtrack_1_1trigger.html">Backtrack::trigger</a></code> Used to control backtracking. May be subclassed to attach additional information.</li>
<li><code>CompilerBug</code> Used for internal compiler errors. Use the BUG() macro wrapper instead of calling this directly.</li>
</ul>
<h2><a class="el" href="namespace_i_r.html" title="a value that can be evaluated at compile-time ">IR</a> Classes</h2>
<p>To make <a class="el" href="namespace_i_r.html" title="a value that can be evaluated at compile-time ">IR</a> class management and extension easier, <a class="el" href="namespace_i_r.html" title="a value that can be evaluated at compile-time ">IR</a> classes are defined in .def files, which are processed by an ir-generator tool to produce the actual <a class="el" href="namespace_i_r.html" title="a value that can be evaluated at compile-time ">IR</a> C++ code. Conceptually, these .def files are just C++ class definitions with the boilerplate removed, and the ir-generator program inserts the boilerplate and splits each class definition into .h and .cpp parts as needed.</p>
<p>The bulk of the "normal" <a class="el" href="namespace_i_r.html" title="a value that can be evaluated at compile-time ">IR</a> is defined in the ir subdirectory, with some frontends and backends having their own extensions to the <a class="el" href="namespace_i_r.html" title="a value that can be evaluated at compile-time ">IR</a> defined in their own ir subdirectories. The ir-generator tool takes reads all the .def files in the tree and constructs a single .h and .cpp file with all the <a class="el" href="namespace_i_r.html" title="a value that can be evaluated at compile-time ">IR</a> class definition code.</p>
<p>All references to <a class="el" href="namespace_i_r.html" title="a value that can be evaluated at compile-time ">IR</a> class objects from other <a class="el" href="namespace_i_r.html" title="a value that can be evaluated at compile-time ">IR</a> class object MUST be as <code>const</code> pointers, to maintain the write-only invariants. Where that is too onerous, <a class="el" href="namespace_i_r.html" title="a value that can be evaluated at compile-time ">IR</a> classes may be directly embedded in other <a class="el" href="namespace_i_r.html" title="a value that can be evaluated at compile-time ">IR</a> objects, rather than by reference. When an <a class="el" href="namespace_i_r.html" title="a value that can be evaluated at compile-time ">IR</a> object is embedded in this way, it becomes modifiable in <code><a class="el" href="class_modifier.html">Modifier</a></code>/<code><a class="el" href="class_transform.html">Transform</a></code> visitors when visiting the containing node, and will not be directly visited itself.</p>
<p>The ir-generator understands both of these mechanisms. Any field declared in an <a class="el" href="namespace_i_r.html" title="a value that can be evaluated at compile-time ">IR</a> class with another <a class="el" href="namespace_i_r.html" title="a value that can be evaluated at compile-time ">IR</a> class as a type will be made a <code>const</code> pointer, unless it has an <code>inline</code> modifier, in which case it will be a directly embedded sub-object.</p>
<p>The ir-generator understands a number of "standard" methods for <a class="el" href="namespace_i_r.html" title="a value that can be evaluated at compile-time ">IR</a> classes &ndash; <code>visit_children</code>, <code>operator==</code>, <code>dbprint</code>, <code>toString</code>, <code>apply</code>. These methods can be declared <em>without</em> any arguments or return types (ie, just the method name followed by a {}-block of code), in which case the standard declaration will be synthesized. If the method is not declared in the .def file, a standard definition (based on the fields declared in the class) will be created. In this way, <em>most</em> classes can avoid including this boilerplate code in the .def file.</p>
<h4><code><a class="el" href="class_i_r_1_1_node.html">IR::Node</a></code></h4>
<p>This is the ultimate abstract base class of all <a class="el" href="namespace_i_r.html" title="a value that can be evaluated at compile-time ">IR</a> nodes and contains only a small amount of data for error reporting and debugging. In general, this info is NEVER compared for equality (so subclasses should never call Node::operator==`) as Nodes that differ only in this information should be considered equal, and not require cloning or the <a class="el" href="namespace_i_r.html" title="a value that can be evaluated at compile-time ">IR</a> tree.</p>
<h4><code><a class="el" href="class_i_r_1_1_vector.html">IR::Vector</a>&lt;T&gt;</code></h4>
<p>This template class holds a vector of (<code>const</code>) pointers to nodes of a particular <code><a class="el" href="class_i_r_1_1_node.html">IR::Node</a></code> subclass. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.12-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Thu Apr 6 2017 for
    <a href="http://p4.org/spec">
    <img class="footer" src="p4-logo.png" alt="P4 Org" /></a></li>
  </ul>
</div>
</body>
</html>
